import com.example.reservas.model.CrearReservaDTO;
import com.example.reservas.model.EstadoReserva;
import com.example.reservas.model.Reserva;
import com.example.reservas.model.ReservaDTO;
import com.example.reservas.repository.ReservaRepository;
import com.example.reservas.service.ReservaMapper;
import com.example.reservas.service.ReservaService;
import com.example.reservas.util.ResourceNotFoundException;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Transactional
public class ReservaServiceImpl implements ReservaService {

    private final ReservaRepository reservaRepository;
    private final ReservaMapper reservaMapper;
    // Asumiremos que los repositorios de Usuario y Clase están en otros microservicios
    // por lo que no validaremos si usuarioId o claseId existen aquí.

    @Override
    public ReservaDTO crearReserva(CrearReservaDTO crearReservaDTO) {
        // 1. Convertir DTO de entrada a Entidad
        Reserva reserva = reservaMapper.crearDTOToEntity(crearReservaDTO);

        // 2. Aplicar lógica de negocio (toda reserva nueva está PENDIENTE)
        reserva.setEstado(EstadoReserva.PENDIENTE);
        // 'id' y 'fechaReserva' (si es @CreationTimestamp) se rellenan solos.

        // 3. Guardar en la BD
        Reserva reservaGuardada = reservaRepository.save(reserva);

        // 4. Devolver el DTO de salida
        return reservaMapper.toDTO(reservaGuardada);
    }

    @Override
    @Transactional(readOnly = true)
    public ReservaDTO obtenerReservaPorId(Long id) {
        Reserva reserva = reservaRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Reserva no encontrada con id: " + id));
        return reservaMapper.toDTO(reserva);
    }

    @Override
    @Transactional(readOnly = true)
    public List<ReservaDTO> obtenerReservasPorUsuario(Long usuarioId) {
        List<Reserva> reservas = reservaRepository.findByUsuarioId(usuarioId);
        return reservas.stream()
                .map(reservaMapper::toDTO)
                .collect(Collectors.toList());
    }

    @Override
    public ReservaDTO cancelarReserva(Long id) {
        // 1. Encontrar la reserva
        Reserva reserva = reservaRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Reserva no encontrada con id: " + id));

        // 2. Aplicar lógica de negocio (no puedes cancelar algo ya cancelado o completado)
        if (reserva.getEstado() == EstadoReserva.CANCELADA || reserva.getEstado() == EstadoReserva.COMPLETADA) {
            throw new IllegalStateException("La reserva ya está finalizada o cancelada.");
        }

        // 3. Cambiar estado y guardar
        reserva.setEstado(EstadoReserva.CANCELADA);
        Reserva reservaCancelada = reservaRepository.save(reserva);

        return reservaMapper.toDTO(reservaCancelada);
    }

    @Override
    @Transactional(readOnly = true)
    public List<ReservaDTO> obtenerTodasLasReservas() {
        return reservaRepository.findAll().stream()
                .map(reservaMapper::toDTO)
                .collect(Collectors.toList());
    }
}